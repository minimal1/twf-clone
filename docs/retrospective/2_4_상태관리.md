# 2.4 상태 관리

## 중앙 집중식 상태

1. 왜 모든 상태를 하나의 구조체에 모았는가?

하나의 구조체를 모아서 엔트리 역할을 하고 있습니다.  
이는 일종의 Layer를 구분짓는 것과 유사하다고 생각합니다.  
각 상태를 각각의 모듈로부터 참조하여 사용할 수도 있으나 이는 DX적으로 피로를 유발합니다.  
한곳에서 관리하여 해당 Layer를 통하면 필요한 상태들이 있다는 걸 인지하도록 만드는게 큰 목적입니다.

1-1. 추가 의견

- Facade Pattern (복잡한 서브시스템을 단순한 인터페이스로)
- Single Source of Truth
- Aggregate Root (DDD 용어)
- 의존성 단순화
- 응집도
- 발견 가능성
- 테스트 용이

2. 접근자 패턴 (`Cursor()`, `Selection()`)의 장점은?

타입 검증이 접근자 내부에서 처리되기에 안정성이 높습니다.  
다른 장점은 모르겠습니다.

2-1. 추가의견

- 캡슐화: 통제된 접근만 허용합니다.
- 유연성: 로직 확장에 용이
- Read-only처리 가능
- App State에 대한 인터페이스 설계 용이 및 이로서 mock 구성편의
- 일관성

3. 상태를 직접 노출하지 않는 이유는?

실질적으론 직접 노출하는 것과 다르진 않습니다.  
다만 DX적으로 엔트리를 통하면 원하는 상태를 관리할 수 있다는 환경이 작업이나 관리에서 효과적이라 생각했습니다.

3-1. 답변 보정
상태 객체에 대한 캡슐화를 통해 안정성을 확보할 수 있습니다.  
하위 상태를 private로 정의하며 selector패턴으로만 제공하기에 외부에서는 통제된 방식으로만 접근 및 활용가능하게 합니다.

## 북마크 시스템

1. Vim의 북마크와 동일한 방식인가?

아마 그런거 같습니다.

2. `map[string]*TreeNode`를 사용한 이유는?

키를 문자열로 하고 그 값을 원하는 노드로 하기 위해서 입니다.
문자열을 사용하여 북마크의 사용자편의성을 높였으며, 포인터로 하며 실제 노드와 동일한 객체를 사용하여 통일감을 확보하였습니다.

3. 북마크가 가리키는 노드가 삭제되면?

북마크도 사라지는 게 적절한 UX로 생각되지만 현재 구현은 안되어 있을겁니다.

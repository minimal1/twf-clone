# 1.1 아키텍처 분석

## 핵심 질문

- 왜 `terminal`, `filetree`, `state`, `views`로 패키지를 분리했을까?
- 각 레이어는 어떤 책임을 가지고 있는가?
- 패키지 간 의존성 방향은 올바른가?

## 답

하나의 역할에만 집중하기 위해 4개의 패키지로 분리했습니다.

### 레이어 역할과 책임

각 패키지의 역할

1. terminal (Infrastructure Layer)
  - I/O 담당 패키지로, 터미널 하드웨어/OS와의 인터페이스를 제공
  - Raw 모드, ANSI 이스케이프 시퀀스 등 저수준 터미널 제어

2. filetree (Domain Layer)
  - 핵심 도메인 패키지로, 파일 시스템 트리 구조와 순회 로직 담당
  - 비즈니스 로직을 처리

3. state (State Management Layer)
  - 어플리케이션의 런타임 상태를 중앙 집중식으로 관리
  - filetree 도메인을 "어떻게 보여줄지"에 대한 상태 관리

4. views (Presentation Layer)
  - 화면 렌더링 담당, 실제로 사용자가 보는 UI 구성

### 의존성 방향

          terminal
              ^
              |
+-------------+-------------+
|                           |
views ------------------> state ------------------> filetree
  |                                                     ^
  |                                                     |
  +-----------------------------------------------------+

의존성 방향 해석 (고수준 ->  저수준)
- views: 가장 구체적인 구현
- state: 중간 레이어 (filetree 도메인을 view를 위해 제공)
- terminal & filetree: 가장 추상적 / 독립적

### 설계 결정 이유

#### 파일 시스템 API를 직접 호출하지 않고 추상화한 이유는?

파일 시스템 API를 그대로 사용한다면 OS 파일시스템 API코드와 제품의 로직이 섞이게됩니다.  
이로인해 제품의 수정 및 확장을 어렵게 만들 수 있습니다.  
구체적인 구현부분은 최소한으로 결합시켜 제품의 전반적인 부분이 유연하도록 유지하기 위함입니다.  

#### 지연 로딩(Lazy Loading)을 구현한 이유는?

효율적인 처리를 위해서 입니다.  
당장 사용하지 않을 데이터를 모두 조회하는 것은 낭비입니다.  
또한 대용량의 데이터가 있을 경우에는 조회하는 시간도 오래걸리며 메모리도 많이 차지합니다.  

#### 상태를 별도 파일로 분리한 이유는? (cursor.go, selection.go, view.go)

서로 다른 관심사이기 때문에 분리합니다.  
이로써 변경에 유리하며, 관련된 기능 테스트에도 효과적입니다.

#### View 인터페이스를 만든 이유는?

다른 뷰를 구현하더라도 같은 api를 가지기때문에 통일성을 확보할 수 있기 때문입니다.  
또한 다형성을 제공해주기때문에 layout에서 view에 구체적 내용을 몰라도 됩니다.  
이렇게 된다면 새로운 뷰를 추가 시 기존 코드 수정이 최소화됩니다.

### 확장성과 유지보수성

#### 다른 터미널 라이브러리(예: tcell, termbox-go)로 교체하기 쉬운가?

OS와의 직접적인 소통과 저수준 기술 등에 대해 응집도가 높기에 terminal 내부만 교체하면 되기때문에 유연한 교체가 가능하다고 생각합니다.  
특히 terminal을 의존하는 타 레이어에선 인터페이스에 의존하기에 내부 구현체 변경을 쉽게 가능합니다.  

#### 새로운 뷰를 추가하기 쉬운가?

쉽습니다.  
뷰 인터페이스를 준수하면 됩니다.  
완성된 뷰를 layout안에서 어디에 보여줄지 결정하면 되어, 다른 레이어의 코드나 다른 뷰의 코드를 수정하지 않아도 됩니다.

#### 개선 가능한 부분은?

먼저 터미널 레이어에도 인터페이스를 추가하면 좋을듯합니다.  
지금도 충분히 외부에는 적절한 인터페이스 API만 제공되지만 터미널 내부 교체하거나 테스트를 위한 mock 객체를 구성할 때,  
구현해야할 인터페이스가 정의되어있다면 작업이 수월하며 제품의 안정성도 높아질것 같습니다.  

두번째로 메인 app 코드입니다.  
해당 코드안에서 여러 레이어들을 가져와 처리하고 있는데, 막상 메인 app 코드에도 적절한 레이어 분리시 가독성에 효과적으로 생각됩니다.  
app 객체에 있는 상태들도 state layer로 옮기고 이벤트 처리도 또한 컨트롤러 레이어 같이 별도로 분리하는 게 좋지않을까 싶습니다.  

### 분리의 장점

분리의 목적은 효과적인 이해를 위함입니다.
그 결과 얻어지는 다양한 장점이 있습니다.
작업자가 잘 이해할 수 있다는 것은 구성 요소들의 맥락이 합리적이며 결이 같다는 걸 말합니다.
전문 용어로 높은 응집도를 가진다는 겁니다.
자연스레 수정할 때가 같은 역할에 한에서만 이뤄지게 됩니다.
결과적으로 역할 분리가 명확하게 되면 모듈이 쉽게 이해되며 기능 추가 및 수정이 수월해집니다.
또한 역할 숙지를 마친 상태라면 여러 작업자들이 동시에 작업할 수 도 있습니다.
"View, Domain, State, I/O Abstraction" 으로 분리는 개발자들의 경험을 통한 지혜라고 볼 수 있습니다.

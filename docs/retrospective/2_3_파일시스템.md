# 2.3 파일 시스템

## 트리 구조 설계

1. 왜 포인터를 사용했는가? (`*TreeNode`)

포인터 사용부문이 크게 2가지입니다.

함수 설계와 자료구조 설계입니다.

먼저 함수 설계에서는 데이터 전달 시 메모리 효율이 큰 이유였다고 생각합니다.  
값을 전달하려면 구조체의 크기 자체를 메모리에 할당하고 복사가 이뤄질텐데 그것보다는 메모리의 주소를 가리키는 포인터가 비용이 적게듭니다.  
혹시 다른 이유도 있다면 알려주세요.

자료구조 설계에서는 하나의 노드의 데이터 변경을 추적하기 용이하기때문입니다.  
서로의 노드간에 부모자식이라는 관계가 성립이 되며 그 관계 속 값들의 변화를 쉽게 파악할 수 있어야합니다.  
이를 값으로 표현하고자한다면 매번 부모나 자식에게 변경된 사항에 대해서 알려줘야합니다.  
이런 걸 각 노드가 알아서 관리하고 포인터로 연결해놓으면 더 용이한 작업을 할 수 있다고 생각합니다.

추가 의견

1. 순환 구조 표현 가능
2. 동일성 보장, == 연산으로 같은 노드임 파악 가능
3. nil 라고 표현 가능

4. `Expanded`와 `Loaded`의 차이는?

Expanded

- 부모 노드로서 자식 노드들이 노출되도록 확장한 상태에 대한 플래그입니다.

Loaded

- 자신의 자식 노드들을 파일 시스템에서 어플리케이션 모델로 불러온 상태에 대한 플래그입니다.

3. 순환 참조 가능성은?

가능성은 있다고 생각합니다.  
파일 시스템에서 자신의 자식 노드가 심볼릭 링크 파일로서 자신의 부모노드를 가리키고 있다면 충분히 가능합니다.  
이를 개선한다면 심볼릭 링크는 리프노드로 처리하고 관련된 링크 정보만 노출하는 정도도 괜찮을거 같습니다.

대응 방법

1. 방문 여부 플래그 지원
2. 깊이 제한 방법

## 지연 로딩 (Lazy Loading)

1. 지연 로딩의 장점은?

필요할 때 원하는 데이터를 가져오는 것이니 자원을 효율적으로 사용할 수 있습니다.  
현재 필요한 메모리양과 불 필요한 I/O를 줄이게됩니다.

2. 단점이나 trade-off는?

전체의 크기를 알기 어렵고,  
어플 사용 중간에 로드하는 시간을 대기해야한다는 점이 trade-off일거 같습니다.

추가 단점

1. 복잡도 증가
2. 일관성 문제
3. 에러 처리

4. 언제 로딩이 실제로 발생하는가?

폴더의 직계 파일을 조회할 때 발생합니다.  
어플리케이션 속에선 폴더를 최초로 expand 할 때 입니다.

## 트리 순회 알고리즘

1. DFS(깊이 우선 탐색)인가 BFS(너비 우선 탐색)인가?

깊이우선탐색입니다.

2. 왜 이 방식을 선택했는가?

잘 모르겠습니다.

이유

1. 파일 트리의 시각적 순서가 DFS와 일치
2. 메모리 효율

- DFS는 깊이가 깊어도 현재 경로만 메모리에
- BFS는 한 레벨의 모든 노드를 메모리에, node_modules는 최악

3. 구현 단순성
4. 캐시 지역성

- DFS는 부모 자식이 메모리에서 가까움, 히트율이 높음

3. 확장되지 않은 노드는 어떻게 처리되는가?

확장되지 않은 노드를 대상으로 특별히 처리하는 건 없습니다.  
대신 아직 로드하지 않은 노드는 무시합니다.

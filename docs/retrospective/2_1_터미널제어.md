# 2.1 터미널 제어

## Raw 모드 vs Cooked 모드

1. Raw 모드는 정확히 무엇인가?

키보드 입력이 즉각처리되는 방식을 말합니다.  
또한 OS가 입력을 전혀 가공하지 않습니다.
입력자체를 바이트로 전달하기에 어플리케이션이 직접 해석 및 처리해야합니다.  

총 4가지의 유형의 입력이 있습니다.  
아스키문자, 아스키제어코드, 유니코드, ANSI 이스케이프 시퀀스로 나뉩니다.  
이 각각을 뜻하는 입력은 1byte~8byte까지 다양한 크기를 가집니다.  
그래서 하나의 입력이 발생했을 때, 단 1byte를 읽는 것이 아닌 여러 바이트를 읽습니다.  
읽은 데이터를 가지고 시스템 제어용 코드를 비교하거나 문자로 처리합니다.  
이러한 처리를 하다보니 Raw모드의 입력 버퍼는 32 or 64 byte가 일반적입니다.  
 - 최대 입력 크기: 일반적으로 6-8 bytes, 특수한 경우 ~20 bytes
 - 2의 제곱수 사용 이유:
   1. CPU 캐시 라인 정렬 (64 bytes = 1 cache line)
   2. 비트 연산 최적화 (% 대신 & 사용 가능)
   3. 메모리 할당기 효율 (2^n 단위로 블록 관리)
 - 이 프로젝트: 64 bytes 사용 (internal/terminal/event.go:90)

Raw와 반대로 줄바꿈(Enter)를 통해 입력을 완성하는 모드는 Cooked 또는 Canonical 라고 합니다.  
해당 모드는 일반적인 shell 사용방식을 생각하면 됩니다.  
원하는 입력을 다 한뒤 엔터를 눌러야 해당 입력들이 하나의 입력으로 전달되어 필요한 처리를 합니다.  

2. 왜 TUI 애플리케이션에 Raw 모드가 필요한가?

TUI 어플리케이션에서 제공할 기능들은 키보드의 입력을 즉각적으로 반응하는 방식입니다.  
그러니 Raw 모드를 사용해야합니다.

3. Raw 모드를 사용할 때 주의할 점은?

정제되지않은 입력들이 들어오기때문에 각 입력들을 알맞게 처리할 수 있어야합니다.  
특히 일반 문자가 아닌 아스키 제어코드나 ANSI 이스케이프 시퀀스 같은 경우엔 입력값들을 잘 확인하도록 로직을 작성해야합니다.  

그리고 Raw 모드를 활성화했다면 반드시 비활성화도 해주어야합니다.  
안할 시 어플리케이션 종료이후 터미널이 망가지게됩니다.  

## `/dev/tty` 사용

1. 왜 stdin/stdout 대신 `/dev/tty`를 사용했는가?

표준 입출력이랑 사용하고픈 터미널과 다를 수 있기때문입니다.  

표준 입출력은 리다이렉션 될 수 있기 때문입니다.  

`twf < input.txt` -> stdin이 파일로 리다이렉션

이런 경우 stdin/stdout으로는 터미널을 제어할수 없습니다.  
반면 `/dev/tty`는 항상 현재 프로세스의 제어 터미널을 가리키므로, 사용자와 소통이 가능합니다.  



2. `/dev/tty`의 장점은?

리다이렉션으로 부터 독립적으로 사용자 터미널과 통신이 가능합니다.  
또한 제어 터미널을 사용한다는 명확성을 제공하며  
이러한 특성상 파이프라인에서도 호환이 됩니다.  

3. Windows에서는 어떻게 해야 할까?

Windows에서도 콘솔 입출력에 직접 접근하는 파일명이 있습니다.
`CONIN$` / `CONOUT$` 
또는 Window Console API를 이용하여 처리할 수 있습니다.  

## ANSI 이스케이프 시퀀스

1. 자주 사용한 ANSI 시퀀스는?
   - 화면 지우기: `\x1b[2J`
   - 커서 이동: `\x1b[H`
   - 색상 변경: `\x1b[38;5;Nm`

2. 대체 화면 버퍼의 목적은?

대체 화면은 TUI 실행 이전의 상태를 보존해주기에 필요합니다.  

3. 색상 시스템을 타입 안전하게 만든 이유는?

직접적으로 입력하기엔 실수하기 쉬운 문자열이다보니 상수화하여 만드는 것이 안정성 높은 코드를 작성할 수 있습니다.  

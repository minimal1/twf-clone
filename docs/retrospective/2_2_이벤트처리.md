# 2.2 이벤트 처리

## 이벤트 인터페이스 설계

1. 왜 구조체가 아닌 인터페이스를 사용했는가?

구조체는 자료구조로서 구체적인 요구사항을 해소하고자 사용되는 요소라 생각합니다.  
다양한 모습을 가질 수 있는 이벤트는 다형성을 지원하며 약속한 API만을 구현하면 내부와 그외의 스펙에 대해선 상관이없는 인터페이스가 적절합니다.

2. 새로운 이벤트 타입 추가가 쉬운가?

쉽습니다. Event 인터페이스만 충족하면 됩니다.

3. 타입 안전성은 어떻게 보장되는가?

이벤트별로 이벤트 인터페이스를 구현하고 있기 때문에 그 인터페이스를 통한 응답값을 가지고 타입에 대한 확인이 가능합니다.  
그렇기에 타입 안정성을 보장할 수 있다고 생각합니다.
즉 EventType()을 통해 타입을 확인한 후 Type Assertion으로 안전하게 변환할 수 있습니다.  
타입 어설션은 컴파일러에서 검증할 수 있기에 런타임 에러를 잡아줍니다.

## 키보드 입력 파싱

1. 화살표 키는 어떻게 파싱되는가? (예: `\x1b[A`)

Mouse Cursor 컨트롤 입력은 ANSI escape sequence 입력 타입입니다.  
해당 타입의 코드표를 보면 화살표 키 별 입력값을 알 수 있습니다.
3바이트로 들어오며 ESC, CSI, {A,B,C,D} 로 구성되어있습니다.

버퍼에 위조합으로 들어온 경우를 찾아내어 내부 KeyPressEvent로 파싱합니다.

2. UTF-8 문자는 어떻게 처리되는가?

UTF-8 뿐 아니라 아스키 코드 내 제어 문자를 제외한 문자들까지 모두 같은 방식으로 처리하고 있습니다.  
Go 내부에는 문자처리에 특화된 타입인 Rune이라고 있습니다.  
이 Rune은 전달된 바이트를 그대로 처리하는 게 아니라 아스키코드 및 유니코드에 맞춰 해석하여 처리합니다.  
Rune은 내부적으로 4바이트 크기의 코드포인트를 관리하게됩니다.

3. Ctrl 조합 키는?

아스키 코드에 있는 제어 문자들로 판단합니다.  
아스키 코드는 1byte로 입력되며 1바이트 크기인 경우엔 맨 처음 파싱하고 있습니다.

원리는 Ctrl을 누르면 해당 문자의 아스키코드 값에서 0x40을 뺀값이 전송됩니다.

## 비동기 이벤트 루프

1. `select` 문은 어떻게 동작하는가?

Go의 동시성 모델 중 하나인 select는 여러 채널을 논 블로킹으로 대기하는 방식입니다.  
caes 문을 통해 여러개의 채널을 논 블로킹으로 대기합니다.  
그러다 하나의 채널에서 반응이 온다면 select 문에선 그 case문에 묶여있는 코드를 실행합니다.  
이때 실행되는 코드 자체는 select 문의 대기를 위한 논블로킹과 무관합니다.  
블로킹일 수도 있습니다.

2. `default` 케이스의 역할은?

대기하는 채널들이 반응이 없다면 실행됩니다.

3. 리사이즈 시그널과 키보드 입력을 동시에 처리하려면?

현재 코드는 대기만 논블로킹이다보니 default 구문이 실행되면 입력이 완료될때까지 리사이즈 처리는 반응하지않습니다.  
이 두개가 서로 다르게 처리하려면 키보드 입력도 채널로 구현하여 default 채널로 인한 블로킹을 줄이면 가능할거 같습니다.
